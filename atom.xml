<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://waterjiao.github.io</id>
    <title>Waterjiao</title>
    <updated>2020-02-02T15:53:35.502Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://waterjiao.github.io"/>
    <link rel="self" href="https://waterjiao.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://waterjiao.github.io/images/avatar.png</logo>
    <icon>https://waterjiao.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Waterjiao</rights>
    <entry>
        <title type="html"><![CDATA[ARTS-第十四周]]></title>
        <id>https://waterjiao.github.io/post/arts-di-14-zhou</id>
        <link href="https://waterjiao.github.io/post/arts-di-14-zhou">
        </link>
        <updated>2020-01-12T13:38:02.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="删除字符串中的所有相邻重复项删除字符串中的所有相邻重复项">删除字符串中的所有相邻重复项（<a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string">删除字符串中的所有相邻重复项</a>）</h4>
<blockquote>
<p>删除字符串中的所有相邻重复项。题目难度为 Easy</p>
</blockquote>
<p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<p><strong>示例1</strong></p>
<pre><code>输入：&quot;abbaca&quot;
输出：&quot;ca&quot;
解释：
例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="删除字符串中的所有相邻重复项删除字符串中的所有相邻重复项">删除字符串中的所有相邻重复项（<a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string">删除字符串中的所有相邻重复项</a>）</h4>
<blockquote>
<p>删除字符串中的所有相邻重复项。题目难度为 Easy</p>
</blockquote>
<p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<p><strong>示例1</strong></p>
<pre><code>输入：&quot;abbaca&quot;
输出：&quot;ca&quot;
解释：
例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。
</code></pre>
<!-- more -->
<p>思路1：</p>
<pre><code class="language-go">func removeDuplicates(S string) string {
	stack := make([]rune, 0, len(S))
	for _, c := range S {
		b := false
		for len(stack) &gt; 0 &amp;&amp; stack[len(stack)-1] == c {
			stack = stack[:len(stack)-1]
			b = true
		}
		if !b {
			stack = append(stack, c)
		}

	}
	return string(stack)
}
</code></pre>
<h3 id="review">Review</h3>
<blockquote>
<p>暂无，待补充，本周坚持每天学习15个英文单词</p>
</blockquote>
<h3 id="tip">Tip</h3>
<h4 id="golang">Golang</h4>
<blockquote>
<p>本周主要是Golang的学习<br>
Don’t communicate by sharing memory; share memory by communicating.</p>
</blockquote>
<ol>
<li>Go 语言字典的键类型不可以是函数类型、字典类型和切片类型。<br>
Go 语言规范规定，在键类型的值之间必须可以施加操作符==和!=。换句话说，键类型的值必须要支持判等操作。由于函数类型、字典类型和切片类型的值并不支持判等操作，所以字典的键类型不能是这些类型。<br>
如果键的类型是数组类型，那么还要确保该类型的元素类型不是函数类型、字典类型或切片类型。<br>
求哈希和判等操作的速度越快，对应的类型就越适合作为键类型。</li>
<li>除了添加键 - 元素对，我们在一个值为nil的字典上做任何操作都不会引起错误。当我们试图在一个值为nil的字典中添加键 - 元素对的时候，Go 语言的运行时系统就会立即抛出一个 panic。</li>
<li>通道channel<br>
对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的。<br>
发送操作和接收操作中对元素值的处理都是不可分割的。<br>
发送操作在完全完成之前会被阻塞。接收操作也是如此。<br>
对于值为nil的通道，不论它的具体类型是什么，对它的发送操作和接收操作都会永久地处于阻塞状态。<br>
退出for - select 循环 https://stackoverflow.com/questions/25469682/break-out-of-select-loop</li>
<li>Go 语言中根本没有继承的概念，它所做的是通过嵌入字段的方式实现了类型之间的组合。(设计模式中多用组合，少用继承，需要回顾下组合模式)</li>
<li>空结构体的指针类型是什么？</li>
</ol>
<h3 id="share">Share</h3>
<blockquote>
<p>暂无，待补充</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Fitness-2020]]></title>
        <id>https://waterjiao.github.io/post/fitness-2020</id>
        <link href="https://waterjiao.github.io/post/fitness-2020">
        </link>
        <updated>2020-01-02T14:53:19.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>1月，学习和健身<br>
|  星期一  | 星期二  |  星期三  |  星期四  |  星期五  |  星期六  | 星期日  |<br>
|  ----  | ----  | ----  | ----  | ----  | ----  | ----  |<br>
|||1(生病)|2(生病)|3(生病)|4(生病)|5(生病)|<br>
|6(生病)|7(生病)|8(生病)|9(生病)|10(生病)|11(年会)|12(生病)|<br>
|13(胸)|14(胸)|15(被耽误)|16(加班)|17(加班)|18(休息)|19()|<br>
| 20   |21   |22   |23   |24   |25   |26   |27   |<br>
| 28   |29   |30   |31   |   |   |   |   |</p>
</blockquote>
<blockquote>
<p>2月，学习、读书和健身<br>
|  星期一  | 星期二  |  星期三  |  星期四  |  星期五  |  星期六  | 星期日  |<br>
|  ----  | ----  | ----  | ----  | ----  | ----  | ----  |<br>
|    |   |   |   |   |1(dance)|2(恢复)|<br>
|  3  |  4 | 5  | 6  |  7 |  8 |  9 |<br>
|    |   |   |   |   |   |   |   |</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ARTS-第十三周]]></title>
        <id>https://waterjiao.github.io/post/arts-di-13-zhou</id>
        <link href="https://waterjiao.github.io/post/arts-di-13-zhou">
        </link>
        <updated>2019-12-29T12:41:43.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="买卖股票的最佳时机买卖股票的最佳时机">买卖股票的最佳时机（<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock">买卖股票的最佳时机</a>）</h4>
<blockquote>
<p>买卖股票的最佳时机。题目难度为 Easy</p>
</blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p><strong>示例1</strong></p>
<pre><code>输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
</code></pre>
<p><strong>示例2</strong></p>
<pre><code>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="买卖股票的最佳时机买卖股票的最佳时机">买卖股票的最佳时机（<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock">买卖股票的最佳时机</a>）</h4>
<blockquote>
<p>买卖股票的最佳时机。题目难度为 Easy</p>
</blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p><strong>示例1</strong></p>
<pre><code>输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
</code></pre>
<p><strong>示例2</strong></p>
<pre><code>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</code></pre>
<!-- more -->
<p>思路1：卖出价格要大于买入价格，循环遍历数组，当前遍历值是买入价格，在买入价格之后才可以是卖出价格，再次循环遍历之后的数组，计算差值，就是利润值。</p>
<pre><code>class Solution {
    public int maxProfit(int[] prices) {
        if(prices==null||prices.length==0) return 0;
        int max = 0;
        for(int i=0;i&lt;prices.length;i++){
            int min = prices[i];
            for(int j=i+1;j&lt;prices.length;j++){
                if(max&lt;prices[j]-prices[i]){
                    max = prices[j]-prices[i];
                }
            }
        }
        return max;
    }
}
</code></pre>
<p>思路2：题意是给出一个数组代表每天的股票金额，让你在最多买卖一次的情况下算出最大的收益额，最简单的就是模拟即可，每次记录当前值减去最小值的差值，与上一次的进行比较然后更新最大值即可。</p>
<pre><code>class Solution {
    public int maxProfit(int[] prices) {
        int max = 0, minPrice = Integer.MAX_VALUE;
        for (int i = 0; i &lt; prices.length; ++i) {
            if (prices[i] &lt; minPrice) minPrice = prices[i];
            int delta = prices[i] - minPrice;
            if (delta &gt; max) max = delta;
        }
        return max;
    }
}
</code></pre>
<h3 id="review">Review</h3>
<blockquote>
<p>暂无，待补充</p>
</blockquote>
<h3 id="tip">Tip</h3>
<h4 id="docker">Docker</h4>
<blockquote>
<p>本周主要是Docker的学习</p>
</blockquote>
<p>一、</p>
<ol>
<li>创建型模式：工厂模式、单例模式</li>
<li></li>
</ol>
<h3 id="share">Share</h3>
<p>分享一篇关于通过源码一步一步分析ArrayList 扩容机制有关的文章<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList-Grow.md">通过源码一步一步分析ArrayList 扩容机制</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ARTS-第十二周]]></title>
        <id>https://waterjiao.github.io/post/arts-di-shi-er-zhou</id>
        <link href="https://waterjiao.github.io/post/arts-di-shi-er-zhou">
        </link>
        <updated>2019-12-09T14:22:03.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="买卖股票的最佳时机买卖股票的最佳时机">买卖股票的最佳时机（<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock">买卖股票的最佳时机</a>）</h4>
<blockquote>
<p>买卖股票的最佳时机。题目难度为 Easy</p>
</blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p><strong>示例1</strong></p>
<pre><code>输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
</code></pre>
<p><strong>示例2</strong></p>
<pre><code>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="买卖股票的最佳时机买卖股票的最佳时机">买卖股票的最佳时机（<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock">买卖股票的最佳时机</a>）</h4>
<blockquote>
<p>买卖股票的最佳时机。题目难度为 Easy</p>
</blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p><strong>示例1</strong></p>
<pre><code>输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
</code></pre>
<p><strong>示例2</strong></p>
<pre><code>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</code></pre>
<!-- more -->
<p>思路1：卖出价格要大于买入价格，循环遍历数组，当前遍历值是买入价格，在买入价格之后才可以是卖出价格，再次循环遍历之后的数组，计算差值，就是利润值。</p>
<pre><code>class Solution {
    public int maxProfit(int[] prices) {
        if(prices==null||prices.length==0) return 0;
        int max = 0;
        for(int i=0;i&lt;prices.length;i++){
            int min = prices[i];
            for(int j=i+1;j&lt;prices.length;j++){
                if(max&lt;prices[j]-prices[i]){
                    max = prices[j]-prices[i];
                }
            }
        }
        return max;
    }
}
</code></pre>
<p>思路2：题意是给出一个数组代表每天的股票金额，让你在最多买卖一次的情况下算出最大的收益额，最简单的就是模拟即可，每次记录当前值减去最小值的差值，与上一次的进行比较然后更新最大值即可。</p>
<pre><code>class Solution {
    public int maxProfit(int[] prices) {
        int max = 0, minPrice = Integer.MAX_VALUE;
        for (int i = 0; i &lt; prices.length; ++i) {
            if (prices[i] &lt; minPrice) minPrice = prices[i];
            int delta = prices[i] - minPrice;
            if (delta &gt; max) max = delta;
        }
        return max;
    }
}
</code></pre>
<h3 id="review">Review</h3>
<blockquote>
<p>暂无，待补充</p>
</blockquote>
<h3 id="tip">Tip</h3>
<h4 id="docker">Docker</h4>
<blockquote>
<p>本周主要是Docker的学习</p>
</blockquote>
<p>一、</p>
<ol>
<li>创建型模式：工厂模式、单例模式</li>
<li></li>
</ol>
<h3 id="share">Share</h3>
<p>分享一篇关于通过源码一步一步分析ArrayList 扩容机制有关的文章<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList-Grow.md">通过源码一步一步分析ArrayList 扩容机制</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ARTS-第十一周]]></title>
        <id>https://waterjiao.github.io/post/arts--di-shi-yi-zhou</id>
        <link href="https://waterjiao.github.io/post/arts--di-shi-yi-zhou">
        </link>
        <updated>2019-12-08T15:36:31.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="买卖股票的最佳时机买卖股票的最佳时机">买卖股票的最佳时机（<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock">买卖股票的最佳时机</a>）</h4>
<blockquote>
<p>买卖股票的最佳时机。题目难度为 Easy</p>
</blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p><strong>示例1</strong></p>
<pre><code>输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
</code></pre>
<p><strong>示例2</strong></p>
<pre><code>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="买卖股票的最佳时机买卖股票的最佳时机">买卖股票的最佳时机（<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock">买卖股票的最佳时机</a>）</h4>
<blockquote>
<p>买卖股票的最佳时机。题目难度为 Easy</p>
</blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p><strong>示例1</strong></p>
<pre><code>输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
</code></pre>
<p><strong>示例2</strong></p>
<pre><code>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</code></pre>
<!-- more -->
<p>思路1：卖出价格要大于买入价格，循环遍历数组，当前遍历值是买入价格，在买入价格之后才可以是卖出价格，再次循环遍历之后的数组，计算差值，就是利润值。</p>
<pre><code>class Solution {
    public int maxProfit(int[] prices) {
        if(prices==null||prices.length==0) return 0;
        int max = 0;
        for(int i=0;i&lt;prices.length;i++){
            int min = prices[i];
            for(int j=i+1;j&lt;prices.length;j++){
                if(max&lt;prices[j]-prices[i]){
                    max = prices[j]-prices[i];
                }
            }
        }
        return max;
    }
}
</code></pre>
<p>思路2：题意是给出一个数组代表每天的股票金额，让你在最多买卖一次的情况下算出最大的收益额，最简单的就是模拟即可，每次记录当前值减去最小值的差值，与上一次的进行比较然后更新最大值即可。</p>
<pre><code>class Solution {
    public int maxProfit(int[] prices) {
        int max = 0, minPrice = Integer.MAX_VALUE;
        for (int i = 0; i &lt; prices.length; ++i) {
            if (prices[i] &lt; minPrice) minPrice = prices[i];
            int delta = prices[i] - minPrice;
            if (delta &gt; max) max = delta;
        }
        return max;
    }
}
</code></pre>
<h3 id="review">Review</h3>
<blockquote>
<p>暂无，待补充</p>
</blockquote>
<h3 id="tip">Tip</h3>
<h4 id="golang">Golang</h4>
<blockquote>
<p>本周主要是Go语言的学习</p>
</blockquote>
<p>一、基础</p>
<ol>
<li>变量<br>
通过var关键字来声明，在函数和方法中还可以使用简短声明</li>
</ol>
<pre><code>var name string

func getName() string{
	name:=&quot;xiaoLi&quot;
	return name
}
</code></pre>
<ol start="2">
<li>常量<br>
通过const关键字来声明</li>
</ol>
<pre><code>const a int = 0
const b int = iota   //0
           c                   //1
					 d                  //2
const	e int = 100
           f                   //4
</code></pre>
<ol start="3">
<li>字符串<br>
Go语言中字符串是用双引号包裹的！<br>
Go语言中字符是用单引号包裹的！</li>
</ol>
<h3 id="share">Share</h3>
<p>分享一篇关于通过源码一步一步分析ArrayList 扩容机制有关的文章<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList-Grow.md">通过源码一步一步分析ArrayList 扩容机制</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构与算法-时间复杂度分析]]></title>
        <id>https://waterjiao.github.io/post/shu-ju-jie-gou-yu-suan-fa-shi-jian-fu-za-du-fen-xi</id>
        <link href="https://waterjiao.github.io/post/shu-ju-jie-gou-yu-suan-fa-shi-jian-fu-za-du-fen-xi">
        </link>
        <updated>2019-11-17T02:32:39.000Z</updated>
        <content type="html"><![CDATA[<p>最好情况时间复杂度（best case time complexity）、最坏情况时间复杂度（worst case time complexity）、平均情况时间复杂度（average case time complexity）、均摊时间复杂度（amortized time complexity）</p>
<pre><code>
// n表示数组array的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i &lt; n; ++i) {
    if (array[i] == x) pos = i;
  }
  return pos;
}
</code></pre>
<p>find函数用于查找array数组中是否含有x数字，如果含有输出x的下标，如果没找到，返回-1。这段代码的时间复杂度为O(n)，用大O来表示时间复杂度，大O中的n是指比较的次数，它的最好和最坏情况时间复杂度都是O(n)，把这段代码稍微改一下.</p>
<pre><code>
// n表示数组array的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i &lt; n; ++i) {
    if (array[i] == x){
			pos = i;
			break;
			}
  }
  return pos;
}
</code></pre>
<p>更改后的代码，它的最好和最坏情况时间复杂度就不同了，原因在于，一旦遍历到数值等于x，循环就结束了，最好情况就是x在数组的头一个，时间复杂度为O(1)，最坏情况就是x不在数组中，时间复杂度为O(n)。</p>
<p>分析add函数的时间复杂度，最好，最坏，平均和均摊时间复杂度</p>
<pre><code>
// 全局变量，大小为10的数组array，长度len，下标i。
int array[] = new int[10]; 
int len = 10;
int i = 0;

// 往数组中添加一个元素
void add(int element) {
   if (i &gt;= len) { // 数组空间不够了
     // 重新申请一个2倍大小的数组空间
     int new_array[] = new int[len*2];
     // 把原来array数组中的数据依次copy到new_array
     for (int j = 0; j &lt; len; ++j) {
       new_array[j] = array[j];
     }
     // new_array复制给array，array现在大小就是2倍len了
     array = new_array;
     len = 2 * len;
   }
   // 将element放到下标为i的位置，下标i加一
   array[i] = element;
   ++i;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ARTS-第九周]]></title>
        <id>https://waterjiao.github.io/post/arts-di-jiu-zhou</id>
        <link href="https://waterjiao.github.io/post/arts-di-jiu-zhou">
        </link>
        <updated>2019-10-19T02:04:48.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="买卖股票的最佳时机买卖股票的最佳时机">买卖股票的最佳时机（<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock">买卖股票的最佳时机</a>）</h4>
<blockquote>
<p>买卖股票的最佳时机。题目难度为 Easy</p>
</blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p><strong>示例1</strong></p>
<pre><code>输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
</code></pre>
<p><strong>示例2</strong></p>
<pre><code>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="买卖股票的最佳时机买卖股票的最佳时机">买卖股票的最佳时机（<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock">买卖股票的最佳时机</a>）</h4>
<blockquote>
<p>买卖股票的最佳时机。题目难度为 Easy</p>
</blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p><strong>示例1</strong></p>
<pre><code>输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
</code></pre>
<p><strong>示例2</strong></p>
<pre><code>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</code></pre>
<!-- more -->
<p>思路1：卖出价格要大于买入价格，循环遍历数组，当前遍历值是买入价格，在买入价格之后才可以是卖出价格，再次循环遍历之后的数组，计算差值，就是利润值。</p>
<pre><code>class Solution {
    public int maxProfit(int[] prices) {
        if(prices==null||prices.length==0) return 0;
        int max = 0;
        for(int i=0;i&lt;prices.length;i++){
            int min = prices[i];
            for(int j=i+1;j&lt;prices.length;j++){
                if(max&lt;prices[j]-prices[i]){
                    max = prices[j]-prices[i];
                }
            }
        }
        return max;
    }
}
</code></pre>
<p>思路2：题意是给出一个数组代表每天的股票金额，让你在最多买卖一次的情况下算出最大的收益额，最简单的就是模拟即可，每次记录当前值减去最小值的差值，与上一次的进行比较然后更新最大值即可。</p>
<pre><code>class Solution {
    public int maxProfit(int[] prices) {
        int max = 0, minPrice = Integer.MAX_VALUE;
        for (int i = 0; i &lt; prices.length; ++i) {
            if (prices[i] &lt; minPrice) minPrice = prices[i];
            int delta = prices[i] - minPrice;
            if (delta &gt; max) max = delta;
        }
        return max;
    }
}
</code></pre>
<h3 id="review">Review</h3>
<blockquote>
<p>暂无，待补充</p>
</blockquote>
<h3 id="tip">Tip</h3>
<h4 id="日常小结5">日常小结5</h4>
<blockquote>
<p>出至极客时间《数据结构与算法》-03 | 复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？-留言评论-姜威</p>
</blockquote>
<p>一、什么是复杂度分析？<br>
1.数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。<br>
2.因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。<br>
3.分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。<br>
4.复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。<br>
二、为什么要进行复杂度分析？<br>
1.和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。<br>
2.掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。<br>
三、如何进行复杂度分析？<br>
1.大O表示法<br>
1）来源<br>
算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n))表示，其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。<br>
2）特点<br>
以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项。<br>
2.复杂度分析法则<br>
1）单段代码看高频：比如循环。<br>
2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。<br>
3）嵌套代码求乘积：比如递归、多重循环等<br>
4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。<br>
四、常用的复杂度级别？<br>
多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，<br>
O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n<sup>2)（平方阶）、O(n</sup>3)（立方阶）<br>
非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，<br>
O(2^n)（指数阶）、O(n!)（阶乘阶）<br>
O(2^n)（指数阶）、O(n!)（阶乘阶）<br>
五、如何掌握好复杂度分析方法？<br>
复杂度分析关键在于多练，所谓孰能生巧。</p>
<h3 id="share">Share</h3>
<p>分享一篇关于通过源码一步一步分析ArrayList 扩容机制有关的文章<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList-Grow.md">通过源码一步一步分析ArrayList 扩容机制</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ARTS-第八周]]></title>
        <id>https://waterjiao.github.io/post/arts-di-ba-zhou</id>
        <link href="https://waterjiao.github.io/post/arts-di-ba-zhou">
        </link>
        <updated>2019-09-23T14:21:48.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="x的平方根sqrtx">x的平方根（<a href="https://leetcode-cn.com/problems/sqrtx/">Sqrt(x)</a>）</h4>
<blockquote>
<p>实现 int sqrt(int x) 函数。题目难度为 Easy</p>
</blockquote>
<p>计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<p><strong>示例</strong></p>
<pre><code>输入: 4
输出: 2

输入: 8
输出: 2
说明: 8 的平方根是 2.82842..., 
         由于返回类型是整数，小数部分将被舍去。
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="x的平方根sqrtx">x的平方根（<a href="https://leetcode-cn.com/problems/sqrtx/">Sqrt(x)</a>）</h4>
<blockquote>
<p>实现 int sqrt(int x) 函数。题目难度为 Easy</p>
</blockquote>
<p>计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<p><strong>示例</strong></p>
<pre><code>输入: 4
输出: 2

输入: 8
输出: 2
说明: 8 的平方根是 2.82842..., 
         由于返回类型是整数，小数部分将被舍去。
</code></pre>
<!-- more -->
<p>思路：牛顿迭代法平方根</p>
<pre><code>class Solution {
    public int mySqrt(int x) {
        long n = x;
        while (n * n &gt; x) {
            n = (n + x / n) &gt;&gt; 1;
        }
        return (int) n;
    }
}
</code></pre>
<h3 id="review">Review</h3>
<blockquote>
<p>暂无，待补充</p>
</blockquote>
<h3 id="tip">Tip</h3>
<h4 id="日常小结4">日常小结4</h4>
<p><strong>网络</strong></p>
<ol>
<li>三次握手</li>
</ol>
<p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p>
<p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p>
<p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p>
<p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p>
<p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p>
<p>也就是只需要三次就够了，不需要额外确认其他信息了。</p>
<ol start="2">
<li>在浏览器中输入url地址 -&gt;&gt; 显示主页的过程</li>
</ol>
<p>DNS解析<br>
TCP连接<br>
发送HTTP请求<br>
服务器处理请求并返回HTTP报文<br>
浏览器解析渲染页面<br>
连接结束</p>
<h3 id="share">Share</h3>
<p>分享一篇关于HTTP长连接、短连接有关的文章<a href="https://www.cnblogs.com/gotodsp/p/6366163.html">HTTP长连接、短连接究竟是什么？</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ARTS-第七周]]></title>
        <id>https://waterjiao.github.io/post/arts-di-qi-zhou</id>
        <link href="https://waterjiao.github.io/post/arts-di-qi-zhou">
        </link>
        <updated>2019-09-08T14:52:51.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="有效的括号valid-parentheses">有效的括号（<a href="https://leetcode-cn.com/problems/valid-parentheses/?utm_source=LCUS&amp;utm_medium=ip_redirect_q_uns&amp;utm_campaign=transfer2china">Valid Parentheses</a>）</h4>
<blockquote>
<p>给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。题目难度为 Easy</p>
</blockquote>
<p>有效字符串需满足：</p>
<ul>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>注意空字符串可被认为是有效字符串。</li>
</ul>
<p><strong>示例</strong></p>
<pre><code>输入: &quot;()&quot;
输出: true

输入: &quot;([)]&quot;
输出: false
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="有效的括号valid-parentheses">有效的括号（<a href="https://leetcode-cn.com/problems/valid-parentheses/?utm_source=LCUS&amp;utm_medium=ip_redirect_q_uns&amp;utm_campaign=transfer2china">Valid Parentheses</a>）</h4>
<blockquote>
<p>给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。题目难度为 Easy</p>
</blockquote>
<p>有效字符串需满足：</p>
<ul>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>注意空字符串可被认为是有效字符串。</li>
</ul>
<p><strong>示例</strong></p>
<pre><code>输入: &quot;()&quot;
输出: true

输入: &quot;([)]&quot;
输出: false
</code></pre>
<!-- more -->
<p>思路：当出现左括号的时候入栈，当遇到右括号时，判断栈顶的左括号是否何其匹配，不匹配的话直接返回 false 即可，最终判断是否空栈即可</p>
<pre><code>class Solution {
    public boolean isValid(String s) {
        char[] stack = new char[s.length() + 1];
        int top = 1;
        for (char c : s.toCharArray()) {
            if (c == '(' || c == '[' || c == '{') {
                stack[top++] = c; 
            } else if (c == ')' &amp;&amp; stack[--top] != '(') {
                return false;
            } else if (c == ']' &amp;&amp; stack[--top] != '[') {
                return false;
            } else if (c == '}' &amp;&amp; stack[--top] != '{') {
                return false;
            }
        }
        return top == 1;
    }
}
</code></pre>
<pre><code>class Solution {
    public boolean isValid(String s) {
        if(s==null||s.length()==0) return true;
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        Map&lt;Char,Char&gt; map = new HashMap&lt;&gt;();
        map.add(')':'(');
        map.add(']':'[');
        map.add('}':'{');
        boolean rightFirst = s.charAt(0).equals(')')||s.charAt(0).equals('}')||s.charAt(0).equals(']');
        if(rightFirst) return false;
        for(int i=0;i&lt;s.length();i++){
            boolean leftFlag = s.charAt(i).equals('(')||s.charAt(i).equals('{')||s.charAt(i).equals('[');
            boolean rightFlag = s.charAt(i).equals(')')||s.charAt(i).equals('}')||s.charAt(i).equals(']');
            if(leftFlag){
                list.add(s.charAt(i))
            }else{
                if(map(s.charAt(i)).equals(list(list.size()-1))){
                    list.del(list.size()-1);
                }else{
                    return false;
                }
            }
        }
        if(list.size()==0){
            return true;
        }
    }
}
</code></pre>
<h3 id="review">Review</h3>
<blockquote>
<p>暂无，待补充</p>
</blockquote>
<h3 id="tip">Tip</h3>
<h4 id="日常小结4">日常小结4</h4>
<p><strong>容器</strong></p>
<ol>
<li>List，Set，Map<br>
List存放数据有序，不唯一<br>
Set存放数据无序，唯一<br>
Map存放键值对</li>
<li>HashMap和HashTable<br>
HashMap不是线程安全的，底层是通过数组+链表/红黑树的方式实现（jdk1.7和jdk1.8）<br>
HashTable是线程安全的，由于使用了sychronized，不建议使用，建议使用ConcurrentHashMap</li>
<li>HashSet底层是HashMap</li>
</ol>
<p><strong>JVM</strong></p>
<ol>
<li>JRE和JDK，JRE是指Java运行环境，包括Java虚拟机和Java基础类库，JDK包括JRE以及javac编译工具等</li>
<li>Java虚拟机加载Java类一般需要三个步骤，加载-链接-初始化<br>
加载：就是查找字节流，并且据此创建类的过程，通过类加载器。启动类加载器（bootstrap class loader），负责加载JRE的lib目录下jar包中的类，扩展类加载器是启动类加载器的孩子，负责加载lib/ext目录下jar包中的类，应用类加载器的父类是扩展类加载器，负责加载应用程序路径下的类。<br>
注意：双亲委派模型。类加载器还提供了命名空间。<br>
链接：是指将创建成的类合并至Java虚拟机中，使之能够执行的过程。它可分为验证、准备和解析三个阶段。</li>
</ol>
<h3 id="share">Share</h3>
<p>分享一篇关于JVM GC有关的文章<a href="https://my.oschina.net/hosee/blog/644618">JVM GC参数以及GC算法的应用</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[影单]]></title>
        <id>https://waterjiao.github.io/post/ying-dan</id>
        <link href="https://waterjiao.github.io/post/ying-dan">
        </link>
        <updated>2019-08-27T14:01:16.000Z</updated>
        <content type="html"><![CDATA[<h3 id="8月">8月</h3>
<blockquote>
<p>对于部分剧集涉及到轻微剧透</p>
</blockquote>
<ol>
<li>
<p>切尔诺贝利-禁区<br>
影评：看着名字以为是个纪录片，没想到是个科幻片，毛子的胆子可不是一般的大，还在看，看后再补充。</p>
</li>
<li>
<p>寄生虫</p>
</li>
<li>
<p>哈利波特与魔法石</p>
</li>
<li>
<p>致命女人（Why Women Kill）</p>
</li>
<li>
<p>小欢喜</p>
</li>
</ol>
<h3 id="11月">11月</h3>
<ol>
<li>无耻之徒</li>
<li>浴血黑帮</li>
<li>小丑</li>
<li></li>
</ol>
]]></content>
    </entry>
</feed>