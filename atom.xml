<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://waterjiao.github.io</id>
    <title>Waterjiao</title>
    <updated>2020-02-17T14:33:14.178Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://waterjiao.github.io"/>
    <link rel="self" href="https://waterjiao.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://waterjiao.github.io/images/avatar.png</logo>
    <icon>https://waterjiao.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Waterjiao</rights>
    <entry>
        <title type="html"><![CDATA[ARTS-第十六周]]></title>
        <id>https://waterjiao.github.io/post/arts-di-shi-liu-zhou</id>
        <link href="https://waterjiao.github.io/post/arts-di-shi-liu-zhou">
        </link>
        <updated>2020-02-15T05:55:31.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="只出现一次的数字只出现一次的数字">只出现一次的数字（<a href="https://leetcode-cn.com/problems/single-number/">只出现一次的数字</a>）</h4>
<blockquote>
<p>只出现一次的数字。题目难度为 Easy</p>
</blockquote>
<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p><strong>示例1</strong></p>
<pre><code>输入: [2,2,1]
输出: 1

输入: [4,1,2,1,2]
输出: 4
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="只出现一次的数字只出现一次的数字">只出现一次的数字（<a href="https://leetcode-cn.com/problems/single-number/">只出现一次的数字</a>）</h4>
<blockquote>
<p>只出现一次的数字。题目难度为 Easy</p>
</blockquote>
<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p><strong>示例1</strong></p>
<pre><code>输入: [2,2,1]
输出: 1

输入: [4,1,2,1,2]
输出: 4
</code></pre>
<!-- more -->
<p>思路1：将数组排序，每隔两个进行遍历，找出不一样的数字即可</p>
<pre><code class="language-go">import &quot;sort&quot;
func singleNumber(nums []int) int {
    sort.Ints(nums)
    var a = nums[0]
    for i:=0;i&lt;len(nums)-1;i+=2{
        if nums[i] != nums[i+1]{
            a = nums[i]
            return a
        }
    }
    if len(nums)%2 != 0 {
        b := len(nums)
        a = nums[b-1]
    }
    return a
}
</code></pre>
<h3 id="review">Review</h3>
<blockquote>
<p>go</p>
</blockquote>
<p><a href="https://www.freecodecamp.org/news/learning-go-from-zero-to-hero-d2a3223b3d86/">Learning go from zero to hero</a><br>
从Packages开始：<br>
Go的代码都写在Package中，main包是整个程序执行的关键，在Go中有很多内建的包。最常使用的就是fmt包。</p>
<h4 id="installing-a-package">Installing a package</h4>
<pre><code>go get &lt;package-url-github&gt;
// example
go get github.com/satori/go.uuid
</code></pre>
<p>要安装的包要放在在工作目录的GOPATH中，安装好的包在GPOPATH/pkg中。</p>
<h4 id="panic">Panic</h4>
<p>Panic is something that is unhandled and is suddenly encountered during a program execution.<br>
例如当多线程对一个map进行读写时，会引起panic。当发生panic时，程序将会被挂起，能在panic后执行的只有defer。</p>
<pre><code>//Go
package main

import &quot;fmt&quot;

func main() {
    f()
    fmt.Println(&quot;Returned normally from f.&quot;)
}

func f() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println(&quot;Recovered in f&quot;, r)
        }
    }()
    fmt.Println(&quot;Calling g.&quot;)
    g(0)
    fmt.Println(&quot;Returned normally from g.&quot;)
}

func g(i int) {
    if i &gt; 3 {
        fmt.Println(&quot;Panicking!&quot;)
        panic(fmt.Sprintf(&quot;%v&quot;, i))
    }
    defer fmt.Println(&quot;Defer in g&quot;, i)
    fmt.Println(&quot;Printing in g&quot;, i)
    g(i + 1)
}
</code></pre>
<h4 id="defer">Defer</h4>
<p>Defer is something that will always get executed at the end of a function.<br>
Defer的作用在于，当我们想在方法结束之前执行一些动作，可以用defer，例如：关闭一个文件。</p>
<h3 id="tip">Tip</h3>
<h4 id="ipv6">IPv6</h4>
<blockquote>
<p>本周主要是网络IPv6和UML的学习<br>
Don’t communicate by sharing memory; share memory by communicating.</p>
</blockquote>
<ol>
<li></li>
</ol>
<h3 id="share">Share</h3>
<blockquote>
<p>go语言并发</p>
</blockquote>
<p>《Go语言实战》读书笔记，直接看飞雪无情的博客<a href="https://www.flysnow.org/2017/04/29/go-in-action-go-runner.html">Go并发示例</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[打卡]]></title>
        <id>https://waterjiao.github.io/post/da-qia</id>
        <link href="https://waterjiao.github.io/post/da-qia">
        </link>
        <updated>2020-02-13T14:07:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="21天打卡计划">21天打卡计划</h1>
<p>Day1<br>
学习课程：《趣谈网络协议》第13讲<br>
打卡笔记：<br>
在网络层，Socket 函数需要指定是 IPv4 还是 IPv6， AF_INET 和 AF_INET6。还要指定是 TCP 还是 UDP，为 SOCK_STREAM 和 SOCK_DGRAM。<br>
对于TCP，服务端要先调用bind函数，给这个Socket赋值IP和Port，再调用listen函数进行监听。客户端用过connect函数发起连接，经过三次握手，这里注意，一旦握手成功，服务端的accept函数会返回另一个Socket，监听Socket和已连接Socket。<br>
对于UDP，没有三次握手，服务端调用bind和listen，由于不需要维护连接状态，只要有一个Socket就可以和多个客户端通信，客户端和服务端都调用sendto和recvfrom。<br>
服务端维护多个Socket连接的方法：<br>
1）多进程<br>
2）多线程<br>
3）IO多路复用，一个线程维护多个Socket<br>
4）IO多路复用，epoll<br>
文件描述符（file descriptor）是内核为了高效管理已被打开的文件所创建的索引，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I/O操作的系统调用都通过文件描述符。</p>
<h1 id="21天打卡计划-2">21天打卡计划</h1>
<p>Day2<br>
学习课程：《趣谈网络协议》第14讲<br>
打卡笔记：<br>
1.应用层 http协议，简单例子，访问网页时，首先根据url通过DNS转化为IP地址，传输层为TCP协议，经过三次握手 进行连接，四次挥手 断开连接，中间过程，IP层，数据链路层，物理层，经过ARP查找MAC地址，发送到目标。而QUIC基于 UDP连接，不需要三次握手，节省资源，提高了性能和效率;<br>
2.http报文包括 请求行 、首部、正文实体，请求行包含方法、SP、URL、版本，首部包含首部字段名、SP、字段值、cr/if。实体就是正文实体。其中，方法就是GET、POST、PUT和DELETE方法。<br>
3.http1.1发送请求时串行，http2.0发送请求时并行，http2.0可以通过头压缩、分帧、二进制编码、多路复用来提升传输效率。<br>
4.Quic 全称 quick udp internet connection ，“快速 UDP 互联网连接”，（和英文 quick 谐音，简称“快”）是由 google 提出的使用 udp 进行多路并发传输的协议。<br>
1）自定义连接机制，不基于四元组，基于随机ID<br>
2）自定义重传机制<br>
3）无阻塞多路复用<br>
4）自定义流量控制。</p>
<h1 id="21天打卡计划-3">21天打卡计划</h1>
<p>Day3<br>
学习课程：《趣谈网络协议》第15讲<br>
打卡笔记：<br>
公钥和私钥是成对的，它们互相解密。公钥加密，私钥解密。私钥数字签名，公钥验证。<br>
http协议不安全，在安全要求下，一般使用https协议，加密的方法有两种对称和不对称。https协议中首先数字证书保证了服务端公钥的可靠性，客户端从CA库里查询确认可靠性，就用证书中公钥去加密pre-master，服务端收到加密后的数据，用自己的私钥去解开，得到pre-master，然后两边都有了①客户端的随机数 ②服务端的随机数 ③pre-master 然后就各自通过计算得到一样的值，就当做公钥。后面就是对称加密的数据传输。这个过程中，对称加密的公钥从来没有在网络上传输过，就很安全了。ca证书中的解密是通过不对称的加密方式实现的，而且保证了公钥的可靠性，所以这里不怕别人拿到公钥，因为私钥他没有，也不怕别人伪造私钥和公钥，因为ca保证了公钥是可靠的。</p>
<h1 id="21天打卡计划-4">21天打卡计划</h1>
<p>Day4<br>
学习课程：《趣谈网络协议》第16讲<br>
打卡笔记：<br>
直播过程：主播端采样+编码+推流至服务端，服务端接流+流处理+分发至分发网络，观众从分发网络拉流+解码+播发。<br>
视频是图片的序列，因此分为三种帧，I帧，P帧，B帧。每一帧又分成多个片，每个片分成多个宏块，压成二进制流为网络提取层单元NALU，NALU之间通过特殊的起始标识符分隔，在每个I帧前要插入单独保存SPS和PPS的NALU，形成NALU序列。<br>
推流使用RTMP协议，基于TCP，主要是确定版本号和时间戳，在传输数据时，需要创建一个流Stream，通过这个Stream来推流publish。推送到流媒体集群的视频流经过转码和分发，可以被客户端通过 RTMP 协议拉取，然后组合为 NALU，解码成视频格式进行播放。这样就可以看直播了。</p>
<h1 id="21天打卡计划-5">21天打卡计划</h1>
<p>Day5<br>
学习课程：《趣谈网络协议》第17讲<br>
打卡笔记：<br>
对于FTP服务器而言，FTP 有两种工作模式，分别是主动模式（PORT）和被动模式（PASV）。两种都是通过21端口进行连接，再开放20或大于1024的端口来进行数据传输。<br>
P2P就是利用tracker中心服务器来记录每个下载者的信息，大家又利用记录了tarcker服务器地址的种子.torrent文件来进行下载，其中还记录了各个下载块。<br>
DHT（Distributed Hash Table）去中心化网络，使用Kademlia 协议，就是每个加入到DHT网络中的节点都要负责存储部分资源信息和成员联系信息。利用哈希值来计算。DHT节点信息划分是通过按位数进行维护，节点信息维护是通过维护列表进行。Kademlia算法中，每个节点只有4个指令，分别是PING、STORE、FIND_NODE和FIND_VALUE。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ARTS-第十五周]]></title>
        <id>https://waterjiao.github.io/post/arts-di-shi-wu-zhou</id>
        <link href="https://waterjiao.github.io/post/arts-di-shi-wu-zhou">
        </link>
        <updated>2020-01-18T13:18:01.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="只出现一次的数字只出现一次的数字">只出现一次的数字（<a href="https://leetcode-cn.com/problems/single-number/">只出现一次的数字</a>）</h4>
<blockquote>
<p>只出现一次的数字。题目难度为 Easy</p>
</blockquote>
<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p><strong>示例1</strong></p>
<pre><code>输入: [2,2,1]
输出: 1

输入: [4,1,2,1,2]
输出: 4
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="只出现一次的数字只出现一次的数字">只出现一次的数字（<a href="https://leetcode-cn.com/problems/single-number/">只出现一次的数字</a>）</h4>
<blockquote>
<p>只出现一次的数字。题目难度为 Easy</p>
</blockquote>
<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p><strong>示例1</strong></p>
<pre><code>输入: [2,2,1]
输出: 1

输入: [4,1,2,1,2]
输出: 4
</code></pre>
<!-- more -->
<p>思路1：将数组排序，每隔两个进行遍历，找出不一样的数字即可</p>
<pre><code class="language-go">import &quot;sort&quot;
func singleNumber(nums []int) int {
    sort.Ints(nums)
    var a = nums[0]
    for i:=0;i&lt;len(nums)-1;i+=2{
        if nums[i] != nums[i+1]{
            a = nums[i]
            return a
        }
    }
    if len(nums)%2 != 0 {
        b := len(nums)
        a = nums[b-1]
    }
    return a
}
</code></pre>
<h3 id="review">Review</h3>
<blockquote>
<p>go</p>
</blockquote>
<p><a href="https://www.freecodecamp.org/news/learning-go-from-zero-to-hero-d2a3223b3d86/">Learning go from zero to hero</a><br>
从Packages开始：<br>
Go的代码都写在Package中，main包是整个程序执行的关键，在Go中有很多内建的包。最常使用的就是fmt包。</p>
<h4 id="installing-a-package">Installing a package</h4>
<pre><code>go get &lt;package-url-github&gt;
// example
go get github.com/satori/go.uuid
</code></pre>
<p>要安装的包要放在在工作目录的GOPATH中，安装好的包在GPOPATH/pkg中。</p>
<h4 id="panic">Panic</h4>
<p>Panic is something that is unhandled and is suddenly encountered during a program execution.<br>
例如当多线程对一个map进行读写时，会引起panic。当发生panic时，程序将会被挂起，能在panic后执行的只有defer。</p>
<pre><code>//Go
package main

import &quot;fmt&quot;

func main() {
    f()
    fmt.Println(&quot;Returned normally from f.&quot;)
}

func f() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println(&quot;Recovered in f&quot;, r)
        }
    }()
    fmt.Println(&quot;Calling g.&quot;)
    g(0)
    fmt.Println(&quot;Returned normally from g.&quot;)
}

func g(i int) {
    if i &gt; 3 {
        fmt.Println(&quot;Panicking!&quot;)
        panic(fmt.Sprintf(&quot;%v&quot;, i))
    }
    defer fmt.Println(&quot;Defer in g&quot;, i)
    fmt.Println(&quot;Printing in g&quot;, i)
    g(i + 1)
}
</code></pre>
<h4 id="defer">Defer</h4>
<p>Defer is something that will always get executed at the end of a function.<br>
Defer的作用在于，当我们想在方法结束之前执行一些动作，可以用defer，例如：关闭一个文件。</p>
<h3 id="tip">Tip</h3>
<h4 id="ipv6">IPv6</h4>
<blockquote>
<p>本周主要是网络IPv6和UML的学习<br>
Don’t communicate by sharing memory; share memory by communicating.</p>
</blockquote>
<ol>
<li></li>
</ol>
<h3 id="share">Share</h3>
<blockquote>
<p>go语言并发</p>
</blockquote>
<p>《Go语言实战》读书笔记，直接看飞雪无情的博客<a href="https://www.flysnow.org/2017/04/29/go-in-action-go-runner.html">Go并发示例</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ARTS-第十四周]]></title>
        <id>https://waterjiao.github.io/post/arts-di-14-zhou</id>
        <link href="https://waterjiao.github.io/post/arts-di-14-zhou">
        </link>
        <updated>2020-01-12T13:38:02.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="删除字符串中的所有相邻重复项删除字符串中的所有相邻重复项">删除字符串中的所有相邻重复项（<a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string">删除字符串中的所有相邻重复项</a>）</h4>
<blockquote>
<p>删除字符串中的所有相邻重复项。题目难度为 Easy</p>
</blockquote>
<p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<p><strong>示例1</strong></p>
<pre><code>输入：&quot;abbaca&quot;
输出：&quot;ca&quot;
解释：
例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="删除字符串中的所有相邻重复项删除字符串中的所有相邻重复项">删除字符串中的所有相邻重复项（<a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string">删除字符串中的所有相邻重复项</a>）</h4>
<blockquote>
<p>删除字符串中的所有相邻重复项。题目难度为 Easy</p>
</blockquote>
<p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<p><strong>示例1</strong></p>
<pre><code>输入：&quot;abbaca&quot;
输出：&quot;ca&quot;
解释：
例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。
</code></pre>
<!-- more -->
<p>思路1：</p>
<pre><code class="language-go">func removeDuplicates(S string) string {
	stack := make([]rune, 0, len(S))
	for _, c := range S {
		b := false
		for len(stack) &gt; 0 &amp;&amp; stack[len(stack)-1] == c {
			stack = stack[:len(stack)-1]
			b = true
		}
		if !b {
			stack = append(stack, c)
		}

	}
	return string(stack)
}
</code></pre>
<h3 id="review">Review</h3>
<blockquote>
<p>暂无，待补充，本周坚持每天学习15个英文单词</p>
</blockquote>
<h3 id="tip">Tip</h3>
<h4 id="golang">Golang</h4>
<blockquote>
<p>本周主要是Golang的学习<br>
Don’t communicate by sharing memory; share memory by communicating.</p>
</blockquote>
<ol>
<li>Go 语言字典的键类型不可以是函数类型、字典类型和切片类型。<br>
Go 语言规范规定，在键类型的值之间必须可以施加操作符==和!=。换句话说，键类型的值必须要支持判等操作。由于函数类型、字典类型和切片类型的值并不支持判等操作，所以字典的键类型不能是这些类型。<br>
如果键的类型是数组类型，那么还要确保该类型的元素类型不是函数类型、字典类型或切片类型。<br>
求哈希和判等操作的速度越快，对应的类型就越适合作为键类型。</li>
<li>除了添加键 - 元素对，我们在一个值为nil的字典上做任何操作都不会引起错误。当我们试图在一个值为nil的字典中添加键 - 元素对的时候，Go 语言的运行时系统就会立即抛出一个 panic。</li>
<li>通道channel<br>
对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的。<br>
发送操作和接收操作中对元素值的处理都是不可分割的。<br>
发送操作在完全完成之前会被阻塞。接收操作也是如此。<br>
对于值为nil的通道，不论它的具体类型是什么，对它的发送操作和接收操作都会永久地处于阻塞状态。<br>
退出for - select 循环 https://stackoverflow.com/questions/25469682/break-out-of-select-loop</li>
<li>Go 语言中根本没有继承的概念，它所做的是通过嵌入字段的方式实现了类型之间的组合。(设计模式中多用组合，少用继承，需要回顾下组合模式)</li>
<li>空结构体的指针类型是什么？</li>
</ol>
<h3 id="share">Share</h3>
<blockquote>
<p>暂无，待补充</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Fitness-2020]]></title>
        <id>https://waterjiao.github.io/post/fitness-2020</id>
        <link href="https://waterjiao.github.io/post/fitness-2020">
        </link>
        <updated>2020-01-02T14:53:19.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>1月，学习和健身<br>
|  星期一  | 星期二  |  星期三  |  星期四  |  星期五  |  星期六  | 星期日  |<br>
|  ----  | ----  | ----  | ----  | ----  | ----  | ----  |<br>
|||1(生病)|2(生病)|3(生病)|4(生病)|5(生病)|<br>
|6(生病)|7(生病)|8(生病)|9(生病)|10(生病)|11(年会)|12(生病)|<br>
|13(胸)|14(胸)|15(被耽误)|16(加班)|17(加班)|18(休息)|19()|<br>
| 20   |21   |22   |23   |24   |25   |26   |27   |<br>
| 28   |29   |30   |31   |   |   |   |   |</p>
</blockquote>
<blockquote>
<p>2月，学习、读书和健身<br>
|  星期一  | 星期二  |  星期三  |  星期四  |  星期五  |  星期六  | 星期日  |<br>
|  ----  | ----  | ----  | ----  | ----  | ----  | ----  |<br>
|    |   |   |   |   |1(dance)|2(恢复)|<br>
|  3(dance)  |  4(休息) | 5(dance)  | 6(休息)  |  7(休息) |  8(休息) |  9(休息) |<br>
|    |   |   |   |   |   |   |   |</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ARTS-第十三周]]></title>
        <id>https://waterjiao.github.io/post/arts-di-13-zhou</id>
        <link href="https://waterjiao.github.io/post/arts-di-13-zhou">
        </link>
        <updated>2019-12-29T12:41:43.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="买卖股票的最佳时机买卖股票的最佳时机">买卖股票的最佳时机（<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock">买卖股票的最佳时机</a>）</h4>
<blockquote>
<p>买卖股票的最佳时机。题目难度为 Easy</p>
</blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p><strong>示例1</strong></p>
<pre><code>输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
</code></pre>
<p><strong>示例2</strong></p>
<pre><code>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="买卖股票的最佳时机买卖股票的最佳时机">买卖股票的最佳时机（<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock">买卖股票的最佳时机</a>）</h4>
<blockquote>
<p>买卖股票的最佳时机。题目难度为 Easy</p>
</blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p><strong>示例1</strong></p>
<pre><code>输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
</code></pre>
<p><strong>示例2</strong></p>
<pre><code>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</code></pre>
<!-- more -->
<p>思路1：卖出价格要大于买入价格，循环遍历数组，当前遍历值是买入价格，在买入价格之后才可以是卖出价格，再次循环遍历之后的数组，计算差值，就是利润值。</p>
<pre><code>class Solution {
    public int maxProfit(int[] prices) {
        if(prices==null||prices.length==0) return 0;
        int max = 0;
        for(int i=0;i&lt;prices.length;i++){
            int min = prices[i];
            for(int j=i+1;j&lt;prices.length;j++){
                if(max&lt;prices[j]-prices[i]){
                    max = prices[j]-prices[i];
                }
            }
        }
        return max;
    }
}
</code></pre>
<p>思路2：题意是给出一个数组代表每天的股票金额，让你在最多买卖一次的情况下算出最大的收益额，最简单的就是模拟即可，每次记录当前值减去最小值的差值，与上一次的进行比较然后更新最大值即可。</p>
<pre><code>class Solution {
    public int maxProfit(int[] prices) {
        int max = 0, minPrice = Integer.MAX_VALUE;
        for (int i = 0; i &lt; prices.length; ++i) {
            if (prices[i] &lt; minPrice) minPrice = prices[i];
            int delta = prices[i] - minPrice;
            if (delta &gt; max) max = delta;
        }
        return max;
    }
}
</code></pre>
<h3 id="review">Review</h3>
<blockquote>
<p>暂无，待补充</p>
</blockquote>
<h3 id="tip">Tip</h3>
<h4 id="docker">Docker</h4>
<blockquote>
<p>本周主要是Docker的学习</p>
</blockquote>
<p>一、</p>
<ol>
<li>创建型模式：工厂模式、单例模式</li>
<li></li>
</ol>
<h3 id="share">Share</h3>
<p>分享一篇关于通过源码一步一步分析ArrayList 扩容机制有关的文章<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList-Grow.md">通过源码一步一步分析ArrayList 扩容机制</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ARTS-第十二周]]></title>
        <id>https://waterjiao.github.io/post/arts-di-shi-er-zhou</id>
        <link href="https://waterjiao.github.io/post/arts-di-shi-er-zhou">
        </link>
        <updated>2019-12-09T14:22:03.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="买卖股票的最佳时机买卖股票的最佳时机">买卖股票的最佳时机（<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock">买卖股票的最佳时机</a>）</h4>
<blockquote>
<p>买卖股票的最佳时机。题目难度为 Easy</p>
</blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p><strong>示例1</strong></p>
<pre><code>输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
</code></pre>
<p><strong>示例2</strong></p>
<pre><code>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="买卖股票的最佳时机买卖股票的最佳时机">买卖股票的最佳时机（<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock">买卖股票的最佳时机</a>）</h4>
<blockquote>
<p>买卖股票的最佳时机。题目难度为 Easy</p>
</blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p><strong>示例1</strong></p>
<pre><code>输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
</code></pre>
<p><strong>示例2</strong></p>
<pre><code>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</code></pre>
<!-- more -->
<p>思路1：卖出价格要大于买入价格，循环遍历数组，当前遍历值是买入价格，在买入价格之后才可以是卖出价格，再次循环遍历之后的数组，计算差值，就是利润值。</p>
<pre><code>class Solution {
    public int maxProfit(int[] prices) {
        if(prices==null||prices.length==0) return 0;
        int max = 0;
        for(int i=0;i&lt;prices.length;i++){
            int min = prices[i];
            for(int j=i+1;j&lt;prices.length;j++){
                if(max&lt;prices[j]-prices[i]){
                    max = prices[j]-prices[i];
                }
            }
        }
        return max;
    }
}
</code></pre>
<p>思路2：题意是给出一个数组代表每天的股票金额，让你在最多买卖一次的情况下算出最大的收益额，最简单的就是模拟即可，每次记录当前值减去最小值的差值，与上一次的进行比较然后更新最大值即可。</p>
<pre><code>class Solution {
    public int maxProfit(int[] prices) {
        int max = 0, minPrice = Integer.MAX_VALUE;
        for (int i = 0; i &lt; prices.length; ++i) {
            if (prices[i] &lt; minPrice) minPrice = prices[i];
            int delta = prices[i] - minPrice;
            if (delta &gt; max) max = delta;
        }
        return max;
    }
}
</code></pre>
<h3 id="review">Review</h3>
<blockquote>
<p>暂无，待补充</p>
</blockquote>
<h3 id="tip">Tip</h3>
<h4 id="docker">Docker</h4>
<blockquote>
<p>本周主要是Docker的学习</p>
</blockquote>
<p>一、</p>
<ol>
<li>创建型模式：工厂模式、单例模式</li>
<li></li>
</ol>
<h3 id="share">Share</h3>
<p>分享一篇关于通过源码一步一步分析ArrayList 扩容机制有关的文章<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList-Grow.md">通过源码一步一步分析ArrayList 扩容机制</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ARTS-第十一周]]></title>
        <id>https://waterjiao.github.io/post/arts--di-shi-yi-zhou</id>
        <link href="https://waterjiao.github.io/post/arts--di-shi-yi-zhou">
        </link>
        <updated>2019-12-08T15:36:31.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="买卖股票的最佳时机买卖股票的最佳时机">买卖股票的最佳时机（<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock">买卖股票的最佳时机</a>）</h4>
<blockquote>
<p>买卖股票的最佳时机。题目难度为 Easy</p>
</blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p><strong>示例1</strong></p>
<pre><code>输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
</code></pre>
<p><strong>示例2</strong></p>
<pre><code>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="买卖股票的最佳时机买卖股票的最佳时机">买卖股票的最佳时机（<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock">买卖股票的最佳时机</a>）</h4>
<blockquote>
<p>买卖股票的最佳时机。题目难度为 Easy</p>
</blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p><strong>示例1</strong></p>
<pre><code>输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
</code></pre>
<p><strong>示例2</strong></p>
<pre><code>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</code></pre>
<!-- more -->
<p>思路1：卖出价格要大于买入价格，循环遍历数组，当前遍历值是买入价格，在买入价格之后才可以是卖出价格，再次循环遍历之后的数组，计算差值，就是利润值。</p>
<pre><code>class Solution {
    public int maxProfit(int[] prices) {
        if(prices==null||prices.length==0) return 0;
        int max = 0;
        for(int i=0;i&lt;prices.length;i++){
            int min = prices[i];
            for(int j=i+1;j&lt;prices.length;j++){
                if(max&lt;prices[j]-prices[i]){
                    max = prices[j]-prices[i];
                }
            }
        }
        return max;
    }
}
</code></pre>
<p>思路2：题意是给出一个数组代表每天的股票金额，让你在最多买卖一次的情况下算出最大的收益额，最简单的就是模拟即可，每次记录当前值减去最小值的差值，与上一次的进行比较然后更新最大值即可。</p>
<pre><code>class Solution {
    public int maxProfit(int[] prices) {
        int max = 0, minPrice = Integer.MAX_VALUE;
        for (int i = 0; i &lt; prices.length; ++i) {
            if (prices[i] &lt; minPrice) minPrice = prices[i];
            int delta = prices[i] - minPrice;
            if (delta &gt; max) max = delta;
        }
        return max;
    }
}
</code></pre>
<h3 id="review">Review</h3>
<blockquote>
<p>暂无，待补充</p>
</blockquote>
<h3 id="tip">Tip</h3>
<h4 id="golang">Golang</h4>
<blockquote>
<p>本周主要是Go语言的学习</p>
</blockquote>
<p>一、基础</p>
<ol>
<li>变量<br>
通过var关键字来声明，在函数和方法中还可以使用简短声明</li>
</ol>
<pre><code>var name string

func getName() string{
	name:=&quot;xiaoLi&quot;
	return name
}
</code></pre>
<ol start="2">
<li>常量<br>
通过const关键字来声明</li>
</ol>
<pre><code>const a int = 0
const b int = iota   //0
           c                   //1
					 d                  //2
const	e int = 100
           f                   //4
</code></pre>
<ol start="3">
<li>字符串<br>
Go语言中字符串是用双引号包裹的！<br>
Go语言中字符是用单引号包裹的！</li>
</ol>
<h3 id="share">Share</h3>
<p>分享一篇关于通过源码一步一步分析ArrayList 扩容机制有关的文章<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList-Grow.md">通过源码一步一步分析ArrayList 扩容机制</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构与算法-时间复杂度分析]]></title>
        <id>https://waterjiao.github.io/post/shu-ju-jie-gou-yu-suan-fa-shi-jian-fu-za-du-fen-xi</id>
        <link href="https://waterjiao.github.io/post/shu-ju-jie-gou-yu-suan-fa-shi-jian-fu-za-du-fen-xi">
        </link>
        <updated>2019-11-17T02:32:39.000Z</updated>
        <content type="html"><![CDATA[<p>最好情况时间复杂度（best case time complexity）、最坏情况时间复杂度（worst case time complexity）、平均情况时间复杂度（average case time complexity）、均摊时间复杂度（amortized time complexity）</p>
<pre><code>
// n表示数组array的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i &lt; n; ++i) {
    if (array[i] == x) pos = i;
  }
  return pos;
}
</code></pre>
<p>find函数用于查找array数组中是否含有x数字，如果含有输出x的下标，如果没找到，返回-1。这段代码的时间复杂度为O(n)，用大O来表示时间复杂度，大O中的n是指比较的次数，它的最好和最坏情况时间复杂度都是O(n)，把这段代码稍微改一下.</p>
<pre><code>
// n表示数组array的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i &lt; n; ++i) {
    if (array[i] == x){
			pos = i;
			break;
			}
  }
  return pos;
}
</code></pre>
<p>更改后的代码，它的最好和最坏情况时间复杂度就不同了，原因在于，一旦遍历到数值等于x，循环就结束了，最好情况就是x在数组的头一个，时间复杂度为O(1)，最坏情况就是x不在数组中，时间复杂度为O(n)。</p>
<p>分析add函数的时间复杂度，最好，最坏，平均和均摊时间复杂度</p>
<pre><code>
// 全局变量，大小为10的数组array，长度len，下标i。
int array[] = new int[10]; 
int len = 10;
int i = 0;

// 往数组中添加一个元素
void add(int element) {
   if (i &gt;= len) { // 数组空间不够了
     // 重新申请一个2倍大小的数组空间
     int new_array[] = new int[len*2];
     // 把原来array数组中的数据依次copy到new_array
     for (int j = 0; j &lt; len; ++j) {
       new_array[j] = array[j];
     }
     // new_array复制给array，array现在大小就是2倍len了
     array = new_array;
     len = 2 * len;
   }
   // 将element放到下标为i的位置，下标i加一
   array[i] = element;
   ++i;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ARTS-第九周]]></title>
        <id>https://waterjiao.github.io/post/arts-di-jiu-zhou</id>
        <link href="https://waterjiao.github.io/post/arts-di-jiu-zhou">
        </link>
        <updated>2019-10-19T02:04:48.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="买卖股票的最佳时机买卖股票的最佳时机">买卖股票的最佳时机（<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock">买卖股票的最佳时机</a>）</h4>
<blockquote>
<p>买卖股票的最佳时机。题目难度为 Easy</p>
</blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p><strong>示例1</strong></p>
<pre><code>输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
</code></pre>
<p><strong>示例2</strong></p>
<pre><code>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="买卖股票的最佳时机买卖股票的最佳时机">买卖股票的最佳时机（<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock">买卖股票的最佳时机</a>）</h4>
<blockquote>
<p>买卖股票的最佳时机。题目难度为 Easy</p>
</blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p><strong>示例1</strong></p>
<pre><code>输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
</code></pre>
<p><strong>示例2</strong></p>
<pre><code>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</code></pre>
<!-- more -->
<p>思路1：卖出价格要大于买入价格，循环遍历数组，当前遍历值是买入价格，在买入价格之后才可以是卖出价格，再次循环遍历之后的数组，计算差值，就是利润值。</p>
<pre><code>class Solution {
    public int maxProfit(int[] prices) {
        if(prices==null||prices.length==0) return 0;
        int max = 0;
        for(int i=0;i&lt;prices.length;i++){
            int min = prices[i];
            for(int j=i+1;j&lt;prices.length;j++){
                if(max&lt;prices[j]-prices[i]){
                    max = prices[j]-prices[i];
                }
            }
        }
        return max;
    }
}
</code></pre>
<p>思路2：题意是给出一个数组代表每天的股票金额，让你在最多买卖一次的情况下算出最大的收益额，最简单的就是模拟即可，每次记录当前值减去最小值的差值，与上一次的进行比较然后更新最大值即可。</p>
<pre><code>class Solution {
    public int maxProfit(int[] prices) {
        int max = 0, minPrice = Integer.MAX_VALUE;
        for (int i = 0; i &lt; prices.length; ++i) {
            if (prices[i] &lt; minPrice) minPrice = prices[i];
            int delta = prices[i] - minPrice;
            if (delta &gt; max) max = delta;
        }
        return max;
    }
}
</code></pre>
<h3 id="review">Review</h3>
<blockquote>
<p>暂无，待补充</p>
</blockquote>
<h3 id="tip">Tip</h3>
<h4 id="日常小结5">日常小结5</h4>
<blockquote>
<p>出至极客时间《数据结构与算法》-03 | 复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？-留言评论-姜威</p>
</blockquote>
<p>一、什么是复杂度分析？<br>
1.数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。<br>
2.因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。<br>
3.分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。<br>
4.复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。<br>
二、为什么要进行复杂度分析？<br>
1.和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。<br>
2.掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。<br>
三、如何进行复杂度分析？<br>
1.大O表示法<br>
1）来源<br>
算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n))表示，其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。<br>
2）特点<br>
以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项。<br>
2.复杂度分析法则<br>
1）单段代码看高频：比如循环。<br>
2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。<br>
3）嵌套代码求乘积：比如递归、多重循环等<br>
4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。<br>
四、常用的复杂度级别？<br>
多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，<br>
O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n<sup>2)（平方阶）、O(n</sup>3)（立方阶）<br>
非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，<br>
O(2^n)（指数阶）、O(n!)（阶乘阶）<br>
O(2^n)（指数阶）、O(n!)（阶乘阶）<br>
五、如何掌握好复杂度分析方法？<br>
复杂度分析关键在于多练，所谓孰能生巧。</p>
<h3 id="share">Share</h3>
<p>分享一篇关于通过源码一步一步分析ArrayList 扩容机制有关的文章<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList-Grow.md">通过源码一步一步分析ArrayList 扩容机制</a></p>
]]></content>
    </entry>
</feed>