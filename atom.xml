<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://waterjiao.github.io</id>
    <title>Waterjiao</title>
    <updated>2019-12-05T15:06:04.920Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://waterjiao.github.io"/>
    <link rel="self" href="https://waterjiao.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://waterjiao.github.io/images/avatar.png</logo>
    <icon>https://waterjiao.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Waterjiao</rights>
    <entry>
        <title type="html"><![CDATA[数据结构与算法-时间复杂度分析]]></title>
        <id>https://waterjiao.github.io/post/shu-ju-jie-gou-yu-suan-fa-shi-jian-fu-za-du-fen-xi</id>
        <link href="https://waterjiao.github.io/post/shu-ju-jie-gou-yu-suan-fa-shi-jian-fu-za-du-fen-xi">
        </link>
        <updated>2019-11-17T02:32:39.000Z</updated>
        <content type="html"><![CDATA[<p>最好情况时间复杂度（best case time complexity）、最坏情况时间复杂度（worst case time complexity）、平均情况时间复杂度（average case time complexity）、均摊时间复杂度（amortized time complexity）</p>
<pre><code>
// n表示数组array的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i &lt; n; ++i) {
    if (array[i] == x) pos = i;
  }
  return pos;
}
</code></pre>
<p>find函数用于查找array数组中是否含有x数字，如果含有输出x的下标，如果没找到，返回-1。这段代码的时间复杂度为O(n)，用大O来表示时间复杂度，大O中的n是指比较的次数，它的最好和最坏情况时间复杂度都是O(n)，把这段代码稍微改一下.</p>
<pre><code>
// n表示数组array的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i &lt; n; ++i) {
    if (array[i] == x){
			pos = i;
			break;
			}
  }
  return pos;
}
</code></pre>
<p>更改后的代码，它的最好和最坏情况时间复杂度就不同了，原因在于，一旦遍历到数值等于x，循环就结束了，最好情况就是x在数组的头一个，时间复杂度为O(1)，最坏情况就是x不在数组中，时间复杂度为O(n)。</p>
<p>分析add函数的时间复杂度，最好，最坏，平均和均摊时间复杂度</p>
<pre><code>
// 全局变量，大小为10的数组array，长度len，下标i。
int array[] = new int[10]; 
int len = 10;
int i = 0;

// 往数组中添加一个元素
void add(int element) {
   if (i &gt;= len) { // 数组空间不够了
     // 重新申请一个2倍大小的数组空间
     int new_array[] = new int[len*2];
     // 把原来array数组中的数据依次copy到new_array
     for (int j = 0; j &lt; len; ++j) {
       new_array[j] = array[j];
     }
     // new_array复制给array，array现在大小就是2倍len了
     array = new_array;
     len = 2 * len;
   }
   // 将element放到下标为i的位置，下标i加一
   array[i] = element;
   ++i;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ARTS-第九周]]></title>
        <id>https://waterjiao.github.io/post/arts-di-jiu-zhou</id>
        <link href="https://waterjiao.github.io/post/arts-di-jiu-zhou">
        </link>
        <updated>2019-10-19T02:04:48.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="买卖股票的最佳时机买卖股票的最佳时机">买卖股票的最佳时机（<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock">买卖股票的最佳时机</a>）</h4>
<blockquote>
<p>买卖股票的最佳时机。题目难度为 Easy</p>
</blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p><strong>示例1</strong></p>
<pre><code>输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
</code></pre>
<p><strong>示例2</strong></p>
<pre><code>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="买卖股票的最佳时机买卖股票的最佳时机">买卖股票的最佳时机（<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock">买卖股票的最佳时机</a>）</h4>
<blockquote>
<p>买卖股票的最佳时机。题目难度为 Easy</p>
</blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p><strong>示例1</strong></p>
<pre><code>输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
</code></pre>
<p><strong>示例2</strong></p>
<pre><code>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</code></pre>
<!-- more -->
<p>思路1：卖出价格要大于买入价格，循环遍历数组，当前遍历值是买入价格，在买入价格之后才可以是卖出价格，再次循环遍历之后的数组，计算差值，就是利润值。</p>
<pre><code>class Solution {
    public int maxProfit(int[] prices) {
        if(prices==null||prices.length==0) return 0;
        int max = 0;
        for(int i=0;i&lt;prices.length;i++){
            int min = prices[i];
            for(int j=i+1;j&lt;prices.length;j++){
                if(max&lt;prices[j]-prices[i]){
                    max = prices[j]-prices[i];
                }
            }
        }
        return max;
    }
}
</code></pre>
<p>思路2：题意是给出一个数组代表每天的股票金额，让你在最多买卖一次的情况下算出最大的收益额，最简单的就是模拟即可，每次记录当前值减去最小值的差值，与上一次的进行比较然后更新最大值即可。</p>
<pre><code>class Solution {
    public int maxProfit(int[] prices) {
        int max = 0, minPrice = Integer.MAX_VALUE;
        for (int i = 0; i &lt; prices.length; ++i) {
            if (prices[i] &lt; minPrice) minPrice = prices[i];
            int delta = prices[i] - minPrice;
            if (delta &gt; max) max = delta;
        }
        return max;
    }
}
</code></pre>
<h3 id="review">Review</h3>
<blockquote>
<p>暂无，待补充</p>
</blockquote>
<h3 id="tip">Tip</h3>
<h4 id="日常小结5">日常小结5</h4>
<blockquote>
<p>出至极客时间《数据结构与算法》-03 | 复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？-留言评论-姜威</p>
</blockquote>
<p>一、什么是复杂度分析？
1.数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。
2.因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。
3.分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。
4.复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。
二、为什么要进行复杂度分析？
1.和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。
2.掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。
三、如何进行复杂度分析？
1.大O表示法
1）来源
算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n))表示，其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。
2）特点
以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项。
2.复杂度分析法则
1）单段代码看高频：比如循环。
2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。
3）嵌套代码求乘积：比如递归、多重循环等
4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。
四、常用的复杂度级别？
多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，
O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶）
非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，
O(2^n)（指数阶）、O(n!)（阶乘阶）
O(2^n)（指数阶）、O(n!)（阶乘阶）
五、如何掌握好复杂度分析方法？
复杂度分析关键在于多练，所谓孰能生巧。</p>
<h3 id="share">Share</h3>
<p>分享一篇关于通过源码一步一步分析ArrayList 扩容机制有关的文章<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList-Grow.md">通过源码一步一步分析ArrayList 扩容机制</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ARTS-第八周]]></title>
        <id>https://waterjiao.github.io/post/arts-di-ba-zhou</id>
        <link href="https://waterjiao.github.io/post/arts-di-ba-zhou">
        </link>
        <updated>2019-09-23T14:21:48.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="x的平方根sqrtx">x的平方根（<a href="https://leetcode-cn.com/problems/sqrtx/">Sqrt(x)</a>）</h4>
<blockquote>
<p>实现 int sqrt(int x) 函数。题目难度为 Easy</p>
</blockquote>
<p>计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<p><strong>示例</strong></p>
<pre><code>输入: 4
输出: 2

输入: 8
输出: 2
说明: 8 的平方根是 2.82842..., 
         由于返回类型是整数，小数部分将被舍去。
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="x的平方根sqrtx">x的平方根（<a href="https://leetcode-cn.com/problems/sqrtx/">Sqrt(x)</a>）</h4>
<blockquote>
<p>实现 int sqrt(int x) 函数。题目难度为 Easy</p>
</blockquote>
<p>计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<p><strong>示例</strong></p>
<pre><code>输入: 4
输出: 2

输入: 8
输出: 2
说明: 8 的平方根是 2.82842..., 
         由于返回类型是整数，小数部分将被舍去。
</code></pre>
<!-- more -->
<p>思路：牛顿迭代法平方根</p>
<pre><code>class Solution {
    public int mySqrt(int x) {
        long n = x;
        while (n * n &gt; x) {
            n = (n + x / n) &gt;&gt; 1;
        }
        return (int) n;
    }
}
</code></pre>
<h3 id="review">Review</h3>
<blockquote>
<p>暂无，待补充</p>
</blockquote>
<h3 id="tip">Tip</h3>
<h4 id="日常小结4">日常小结4</h4>
<p><strong>网络</strong></p>
<ol>
<li>三次握手</li>
</ol>
<p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p>
<p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p>
<p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p>
<p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p>
<p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p>
<p>也就是只需要三次就够了，不需要额外确认其他信息了。</p>
<ol start="2">
<li>在浏览器中输入url地址 -&gt;&gt; 显示主页的过程</li>
</ol>
<p>DNS解析
TCP连接
发送HTTP请求
服务器处理请求并返回HTTP报文
浏览器解析渲染页面
连接结束</p>
<h3 id="share">Share</h3>
<p>分享一篇关于HTTP长连接、短连接有关的文章<a href="https://www.cnblogs.com/gotodsp/p/6366163.html">HTTP长连接、短连接究竟是什么？</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ARTS-第七周]]></title>
        <id>https://waterjiao.github.io/post/arts-di-qi-zhou</id>
        <link href="https://waterjiao.github.io/post/arts-di-qi-zhou">
        </link>
        <updated>2019-09-08T14:52:51.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="有效的括号valid-parentheses">有效的括号（<a href="https://leetcode-cn.com/problems/valid-parentheses/?utm_source=LCUS&amp;utm_medium=ip_redirect_q_uns&amp;utm_campaign=transfer2china">Valid Parentheses</a>）</h4>
<blockquote>
<p>给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。题目难度为 Easy</p>
</blockquote>
<p>有效字符串需满足：</p>
<ul>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>注意空字符串可被认为是有效字符串。</li>
</ul>
<p><strong>示例</strong></p>
<pre><code>输入: &quot;()&quot;
输出: true

输入: &quot;([)]&quot;
输出: false
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="有效的括号valid-parentheses">有效的括号（<a href="https://leetcode-cn.com/problems/valid-parentheses/?utm_source=LCUS&amp;utm_medium=ip_redirect_q_uns&amp;utm_campaign=transfer2china">Valid Parentheses</a>）</h4>
<blockquote>
<p>给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。题目难度为 Easy</p>
</blockquote>
<p>有效字符串需满足：</p>
<ul>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>注意空字符串可被认为是有效字符串。</li>
</ul>
<p><strong>示例</strong></p>
<pre><code>输入: &quot;()&quot;
输出: true

输入: &quot;([)]&quot;
输出: false
</code></pre>
<!-- more -->
<p>思路：当出现左括号的时候入栈，当遇到右括号时，判断栈顶的左括号是否何其匹配，不匹配的话直接返回 false 即可，最终判断是否空栈即可</p>
<pre><code>class Solution {
    public boolean isValid(String s) {
        char[] stack = new char[s.length() + 1];
        int top = 1;
        for (char c : s.toCharArray()) {
            if (c == '(' || c == '[' || c == '{') {
                stack[top++] = c; 
            } else if (c == ')' &amp;&amp; stack[--top] != '(') {
                return false;
            } else if (c == ']' &amp;&amp; stack[--top] != '[') {
                return false;
            } else if (c == '}' &amp;&amp; stack[--top] != '{') {
                return false;
            }
        }
        return top == 1;
    }
}
</code></pre>
<pre><code>class Solution {
    public boolean isValid(String s) {
        if(s==null||s.length()==0) return true;
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        Map&lt;Char,Char&gt; map = new HashMap&lt;&gt;();
        map.add(')':'(');
        map.add(']':'[');
        map.add('}':'{');
        boolean rightFirst = s.charAt(0).equals(')')||s.charAt(0).equals('}')||s.charAt(0).equals(']');
        if(rightFirst) return false;
        for(int i=0;i&lt;s.length();i++){
            boolean leftFlag = s.charAt(i).equals('(')||s.charAt(i).equals('{')||s.charAt(i).equals('[');
            boolean rightFlag = s.charAt(i).equals(')')||s.charAt(i).equals('}')||s.charAt(i).equals(']');
            if(leftFlag){
                list.add(s.charAt(i))
            }else{
                if(map(s.charAt(i)).equals(list(list.size()-1))){
                    list.del(list.size()-1);
                }else{
                    return false;
                }
            }
        }
        if(list.size()==0){
            return true;
        }
    }
}
</code></pre>
<h3 id="review">Review</h3>
<blockquote>
<p>暂无，待补充</p>
</blockquote>
<h3 id="tip">Tip</h3>
<h4 id="日常小结4">日常小结4</h4>
<p><strong>容器</strong></p>
<ol>
<li>List，Set，Map
List存放数据有序，不唯一
Set存放数据无序，唯一
Map存放键值对</li>
<li>HashMap和HashTable
HashMap不是线程安全的，底层是通过数组+链表/红黑树的方式实现（jdk1.7和jdk1.8）
HashTable是线程安全的，由于使用了sychronized，不建议使用，建议使用ConcurrentHashMap</li>
<li>HashSet底层是HashMap</li>
</ol>
<p><strong>JVM</strong></p>
<ol>
<li>JRE和JDK，JRE是指Java运行环境，包括Java虚拟机和Java基础类库，JDK包括JRE以及javac编译工具等</li>
<li>Java虚拟机加载Java类一般需要三个步骤，加载-链接-初始化
加载：就是查找字节流，并且据此创建类的过程，通过类加载器。启动类加载器（bootstrap class loader），负责加载JRE的lib目录下jar包中的类，扩展类加载器是启动类加载器的孩子，负责加载lib/ext目录下jar包中的类，应用类加载器的父类是扩展类加载器，负责加载应用程序路径下的类。
注意：双亲委派模型。类加载器还提供了命名空间。
链接：是指将创建成的类合并至Java虚拟机中，使之能够执行的过程。它可分为验证、准备和解析三个阶段。</li>
</ol>
<h3 id="share">Share</h3>
<p>分享一篇关于JVM GC有关的文章<a href="https://my.oschina.net/hosee/blog/644618">JVM GC参数以及GC算法的应用</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[影单]]></title>
        <id>https://waterjiao.github.io/post/ying-dan</id>
        <link href="https://waterjiao.github.io/post/ying-dan">
        </link>
        <updated>2019-08-27T14:01:16.000Z</updated>
        <content type="html"><![CDATA[<h3 id="8月">8月</h3>
<blockquote>
<p>对于部分剧集涉及到轻微剧透</p>
</blockquote>
<ol>
<li>
<p>切尔诺贝利-禁区
影评：看着名字以为是个纪录片，没想到是个科幻片，毛子的胆子可不是一般的大，还在看，看后再补充。</p>
</li>
<li>
<p>寄生虫</p>
</li>
<li>
<p>哈利波特与魔法石</p>
</li>
<li>
<p>致命女人（Why Women Kill）</p>
</li>
<li>
<p>小欢喜</p>
</li>
</ol>
<h3 id="11月">11月</h3>
<ol>
<li>无耻之徒</li>
<li>浴血黑帮</li>
<li>小丑</li>
<li></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ARTS-第六周]]></title>
        <id>https://waterjiao.github.io/post/arts-di-liu-zhou</id>
        <link href="https://waterjiao.github.io/post/arts-di-liu-zhou">
        </link>
        <updated>2019-08-15T13:35:36.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="最长公共前缀longest-common-prefix">最长公共前缀（<a href="https://leetcode-cn.com/problems/longest-common-prefix/?utm_source=LCUS&amp;utm_medium=ip_redirect_q_uns&amp;utm_campaign=transfer2china">Longest Common Prefix</a>）</h4>
<blockquote>
<p>编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 &quot;&quot;。题目难度为 Easy</p>
</blockquote>
<p><strong>示例</strong></p>
<pre><code>输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]
输出: &quot;fl&quot;

输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]
输出: &quot;&quot;
解释: 输入不存在公共前缀。
</code></pre>
<p><strong>说明:</strong>
所有输入只包含小写字母 a-z 。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="最长公共前缀longest-common-prefix">最长公共前缀（<a href="https://leetcode-cn.com/problems/longest-common-prefix/?utm_source=LCUS&amp;utm_medium=ip_redirect_q_uns&amp;utm_campaign=transfer2china">Longest Common Prefix</a>）</h4>
<blockquote>
<p>编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 &quot;&quot;。题目难度为 Easy</p>
</blockquote>
<p><strong>示例</strong></p>
<pre><code>输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]
输出: &quot;fl&quot;

输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]
输出: &quot;&quot;
解释: 输入不存在公共前缀。
</code></pre>
<p><strong>说明:</strong>
所有输入只包含小写字母 a-z 。</p>
<!-- more -->
<p>思路：找出最短的那个字符串的长度 minLen，然后在 0...minLen 的范围比较所有字符串，如果比较到有不同的字符，那么直接返回当前索引长度的字符串即可，否则最后返回最短的字符串即可。</p>
<pre><code>class Solution {
    public String longestCommonPrefix(String[] strs) {
        int len = strs.length;
        if (len == 0) return &quot;&quot;;
        int minLen = 0x7fffffff;
        for (String str : strs) minLen = Math.min(minLen, str.length());
        for (int j = 0; j &lt; minLen; ++j)
            for (int i = 1; i &lt; len; ++i)
                if (strs[0].charAt(j) != strs[i].charAt(j))
                    return strs[0].substring(0, j);
        return strs[0].substring(0, minLen);
    }
}
</code></pre>
<h3 id="review">Review</h3>
<blockquote>
<p>暂无，待补充</p>
</blockquote>
<h3 id="tip">Tip</h3>
<h4 id="日常小结3">日常小结3</h4>
<p><strong>线程</strong></p>
<ol>
<li>wait和notify</li>
</ol>
<pre><code>public final void wait() throws InterruptedException
public final void wait(long timeout) throws InterruptedException

public final native void notify()
public final native void notifyAll()
</code></pre>
<p>每个对象都有一个等待队列：条件队列。当调用notify()和notifyAll()时，从条件队列中移除，并唤醒</p>
<ol start="2">
<li>单例模式
如何写好一个单例模式，不多说，直接写好，双重检测锁</li>
</ol>
<pre><code>public class Singleton{
    private volatile Singleton singleton = null;
		private Singleton(){}
		public static Singleton getSingleton(){
		    if(singleton != null){
				    synchronize(Singleton.class){
						    if(singleton != null){
								    singleton = Singleton.getSingleton();
										return singleton;
								}
						}
				}
				return singleton;
		}
}
</code></pre>
<p><strong>注意</strong>
volatile和synchronized的区别，voilate关键字是用于内存可见，由于计算机中能够存储数据的地方有很多，当发生数据修改或者数据更改时，并不一定都是内存可见的，使用volatile关键字能够避免由于计算机指令计算所带来的影响。synchronzied关键字是提供锁，可用于实例方法，静态方法，代码块上，可以避免一些多线程使用所带来的问题。</p>
<ul>
<li>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。</li>
<li>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞</li>
<li>volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。</li>
<li>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。</li>
</ul>
<h3 id="share">Share</h3>
<p>分享一篇关于事物隔离级别的文章<a href="https://github.com/waterjiao/JavaGuide/blob/master/docs/database/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB(%E5%9B%BE%E6%96%87%E8%AF%A6%E8%A7%A3).md">事务隔离级别(图文详解)</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[macOS效率手册-持续更新]]></title>
        <id>https://waterjiao.github.io/post/macos-xiao-lu-shou-ce-chi-xu-geng-xin</id>
        <link href="https://waterjiao.github.io/post/macos-xiao-lu-shou-ce-chi-xu-geng-xin">
        </link>
        <updated>2019-08-05T14:13:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="macos基础配置">macOS基础配置</h2>
<ol>
<li>锁定拖拽
在系统偏好设置-辅助功能-鼠标与触控板-启用拖拽-锁定拖拽
双击想要拖动的内容，在第二次单击时不释放，就可以拖拽文件啦</li>
<li>侧边放置dock，将功能键F1等设置为标准功能键，特殊功能需要Fn键配合使用</li>
<li>壮壮，希望你个小毛孩一切安好</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ARTS-第五周]]></title>
        <id>https://waterjiao.github.io/post/arts-di-wu-zhou</id>
        <link href="https://waterjiao.github.io/post/arts-di-wu-zhou">
        </link>
        <updated>2019-08-05T14:11:29.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="罗马数字转整数roman-to-integer">罗马数字转整数（<a href="https://leetcode-cn.com/problems/integer-to-roman/">Roman to Integer</a>）</h4>
<blockquote>
<p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。题目难度为 Easy</p>
</blockquote>
<p><strong>示例</strong></p>
<pre><code>输入: &quot;III&quot;
输出: 3

输入: &quot;MCMXCIV&quot;
输出:1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="罗马数字转整数roman-to-integer">罗马数字转整数（<a href="https://leetcode-cn.com/problems/integer-to-roman/">Roman to Integer</a>）</h4>
<blockquote>
<p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。题目难度为 Easy</p>
</blockquote>
<p><strong>示例</strong></p>
<pre><code>输入: &quot;III&quot;
输出: 3

输入: &quot;MCMXCIV&quot;
输出:1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.
</code></pre>
<!-- more -->
<p>思路：利用 map 来完成罗马数字的 7 个数字符号：I、V、X、L、C、D、M 和整数的映射关系，对应1，5，10，50，100，500，1000，如果小的数字在大的数字的左边，表示的数为大的数字减去小的数字</p>
<pre><code>class Solution {
    public int romanToInt(String s) {
        Map&lt;Character,Integer&gt; map = new HashMap&lt;&gt;();
				map.put('I',1);
				map.put('V',5);
				map.put('X',10);
				map.put('L',50);
				map.put('C',100);
				map.put('D',500);
				map.put('M',1000);
				int length = s.length();
				int sum = map.get(s.charAt(length-1));
			  for( int i= length-2;i&gt;0;i--){
				    if (map.get(s.charAt(i)) &lt; map.get(s.charAt(i + 1))) {
                sum -= map.get(s.charAt(i));
            } else {
                sum += map.get(s.charAt(i));
            }
        }
        return sum;
    }
}
</code></pre>
<h3 id="review">Review</h3>
<blockquote>
<p>暂无，待补充</p>
</blockquote>
<h3 id="tip">Tip</h3>
<h4 id="日常小结2">日常小结2</h4>
<p><strong>线程</strong></p>
<ol>
<li>线程的五种状态：新建、就绪、运行、阻塞（等待资源）和终止</li>
<li>sleep()方法，抛出InterruptedException
public static native void sleep(long millis) throws InterruptedException</li>
<li>yeild()方法，让出cpu时间
public static native void yeild()
native关键字说明其修饰方法是一个原生态方法，方法实现不是当前文件，而是在其他语言（如C和    C++）实现的文件中</li>
<li>join方法，让调用join的线程等待该线程结束
public final void join() throws InterruptedException</li>
<li>当线程不安全时（对同一对象进行操作时，没有加锁），可以使用synchronized关键字，使用显示锁，使用原子变量，使其变得安全</li>
<li>内存可见性：一个线程对内存的修改，另一个线程看不到，一是修改没有及时同步到内存，二是另一个线程根本就没有从内存中读。使用voilate关键字，或者使用synchronized关键字、显式锁同步。</li>
<li>synchronized，修饰类的实例方法、静态方法和代码块
synchronized实例方法实际保护的是同一个对象的方法调用，一般在保护变量时，需要在所有访问该变量的方法上加上synchronized</li>
<li>原子变量
AtomicInteger，原子变量，包含一些以原子方式实现组合操作的方法</li>
</ol>
<pre><code>		public class AtomicIntegerDemo{
	      private static AtomicInteger counter = new AtomicInteger(0);
				static class Visitor extends Thread{
				    @Override
						public void run(){
						    for(int i=0;i&lt;1000;i++){
								    counter.incrementAndGet();
								}
						}
				}
		}
		
</code></pre>
<p><strong>线程池</strong></p>
<p>什么是线程池，如何使用，为什么要用？</p>
<ol>
<li>减少创建和销毁线程的开销</li>
<li>根据情况调节线程池中的线程的数量</li>
</ol>
<p>Executor接口来执行线程池的任务
ExecutorService接口来管理和控制任务
newFixedThreadPool(int)在池中创建线程
newCachedThreadPool()会创建新的线程，当池中所有线程都处于运行状态，60s销毁
线程池的四个组成部分：</p>
<ol>
<li>线程池管理</li>
<li>工作线程</li>
<li>任务接口</li>
<li>任务队列</li>
</ol>
<ul>
<li>newSingleThreadExecutor 唯一线程，出错新建</li>
<li>newFixedThreadPool(int) 创建固定数量的线程池</li>
<li>newCachedThreadPool 创建缓存线程池，60s销毁</li>
<li>newScheduledThreadPool 创建一个大小无限的线程池</li>
</ul>
<h3 id="share">Share</h3>
<p>分享一篇美团技术团队的[Java NIO浅析](https://zhuanlan.zhihu.com/p/23488863</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ARTS-第四周]]></title>
        <id>https://waterjiao.github.io/post/arts-di-si-zhou</id>
        <link href="https://waterjiao.github.io/post/arts-di-si-zhou">
        </link>
        <updated>2019-08-04T02:47:22.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="回文数palindrome-number">回文数（<a href="https://leetcode.com/problems/palindrome-number">Palindrome Number</a>）</h4>
<blockquote>
<p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。题目难度为 Easy</p>
</blockquote>
<p><strong>示例</strong></p>
<pre><code>输入：121
输出：true

输入：-121
输出：false
</code></pre>
<p><strong>进阶</strong>
不将整数转化为字符串</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="回文数palindrome-number">回文数（<a href="https://leetcode.com/problems/palindrome-number">Palindrome Number</a>）</h4>
<blockquote>
<p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。题目难度为 Easy</p>
</blockquote>
<p><strong>示例</strong></p>
<pre><code>输入：121
输出：true

输入：-121
输出：false
</code></pre>
<p><strong>进阶</strong>
不将整数转化为字符串</p>
<!-- more -->
<p>思路：不将整数转化为字符串，首先可以确定的是负数一定不是回文数，因为带有负数符号，接着只需要比较数字倒置后的大小是否和之前数字大小相同即可。</p>
<pre><code>class Solution{
	public boolean isPalindrome(int x) {
		if(x&lt;0) return false;
		int revse = 0;
		int origin = x;
		while(x!=0){
			revse = revse*10+x%10;
			x = x/10;
			}
	return revse==origin;
}
</code></pre>
<h3 id="review">Review</h3>
<blockquote>
<p><a href="https://www.infoq.com/articles/single-file-execution-java11/">Running Single-file Programs without Compiling in Java 11</a></p>
</blockquote>
<p>在java11之前，写完helloworld后，需要javac生成helloworld.class文件，再使用java helloworld来运行程序，在java11，只需要使用java helloworld.java即可。</p>
<ol>
<li>java11可以像脚本一样运行单文件</li>
<li>一个文件下可以有多个公共类</li>
<li>接1，单文件可以不需要class文件</li>
<li>运行时，文件名和类名可以不相同</li>
</ol>
<h3 id="tip">Tip</h3>
<h4 id="日常小结1">日常小结1</h4>
<p><strong>反射</strong></p>
<p>java反射机制是在运行状态中，对于任意一个类都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意方法和属性。
获取class对象的三种方式：</p>
<ol>
<li>Object-&gt;getClass()</li>
<li>任何数据类型都有一个静态的class属性</li>
<li>通过class类的静态方法：forName(String className)</li>
</ol>
<p><strong>Arrays.asList()</strong>
Arrays.asList()可以将数组转化为集合，但转化后底层其实还是数组，Arrays.asList()返回的是java.util.Arrays的一个内部类class java.util.Arrays$ArrayList</p>
<pre><code>String[] str = new String[]{&quot;you&quot;,&quot;me&quot;);
List&lt;String&gt; list = Arrays.asList(str);
</code></pre>
<ol>
<li>底层还是数组</li>
</ol>
<pre><code>list.add(&quot;he&quot;) //抛出异常UnsupportedOperationException()
public void add(int index, E element) {
        throw new UnsupportedOperationException();
}
</code></pre>
<p>如果想要使其不抛出异常，则要使用</p>
<pre><code>List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(str));
</code></pre>
<ol start="2">
<li>改变原有数组的内容，list也随着改变</li>
</ol>
<pre><code>str[0] = &quot;he&quot;;
System.out.println(list.get(0)); //输出he
</code></pre>
<p><strong>重载和重写</strong></p>
<p>重载：发生在同一类中，方法名必须相同，参数类型不同，个数不同，顺序不同，方法返回值和访问值可以不同，发生在编译时。
重写：发生在子类父类中，方法名，参数列表必须相同，返回值范围小于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类，如果父类的访问修饰方法为private，则子类不能重写该方法。</p>
<h3 id="share">Share</h3>
<p>分享一篇关于如何学习Java IO<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247484946&amp;idx=1&amp;sn=043b054de3aef29bf3ff80eea15c16fd&amp;source=41#wechat_redirect">Java IO，硬骨头也能变软</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ARTS-第三周]]></title>
        <id>https://waterjiao.github.io/post/arts</id>
        <link href="https://waterjiao.github.io/post/arts">
        </link>
        <updated>2019-07-21T09:38:08.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="无重复字符的最长子串longest-substring-without-repeating-characters">无重复字符的最长子串（<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">Longest Substring Without Repeating Characters</a>）</h4>
<blockquote>
<p>无重复字符的最长子串。题目难度为 Medium</p>
</blockquote>
<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="arts">ARTS</h2>
<h3 id="algorithm">Algorithm</h3>
<h4 id="无重复字符的最长子串longest-substring-without-repeating-characters">无重复字符的最长子串（<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">Longest Substring Without Repeating Characters</a>）</h4>
<blockquote>
<p>无重复字符的最长子串。题目难度为 Medium</p>
</blockquote>
<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<!-- more -->
<p>思路：字符串含有不同的字符，这些字符在ASCII表中占据128位，所以使用一个128位的数组来存储，例如hash['a']=3，代表a字符在遍历字符串时，前一次出现a字符的索引为3，preP为上次出现的最大索引，与当前索引做差就是最大的长度。</p>
<pre><code>class Solution{
    public int lengthOfLongestSubstring(String s) {
        int len;
        if (s == null || (len = s.length()) == 0) return 0;
        int preP = 0, max = 0;
        int[] hash = new int[128];
        for (int i = 0; i &lt; len; ++i) {
            char c = s.charAt(i);
            if (hash[c] &gt; preP) {
                preP = hash[c];
            }
            int l = i - preP + 1;
            hash[c] = i + 1;
            if (l &gt; max) max = l;
        }
        return max;
}
</code></pre>
<h3 id="review">Review</h3>
<blockquote>
<p><a href="https://www.infoq.com/articles/test-driven-design-java/?useSponsorshipSuggestions=true">Test-Driven Development: Really, It’s a Design Technique</a></p>
</blockquote>
<p>TDD 是敏捷开发中的一项核心实践和技术，也是一种设计方法论。TDD的原理是在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码。TDD 是 XP（Extreme Programming）的核心实践。它的主要推动者是 Kent Beck。</p>
<p>TDD的用法：</p>
<ol>
<li>创建测试相关类，方法</li>
<li>写一个测试用例</li>
<li>Red State，不通过上一步所写的测试用例</li>
<li>Green State，改动代码使其通过测试用例</li>
<li>Refactoring state，重构，消除重复的，不用的，优化设计结构，也称为Bule State</li>
</ol>
<p>TDD的优势：</p>
<ol>
<li>更好的软件</li>
<li>避免冗余</li>
<li>新的特性</li>
<li>有文档</li>
</ol>
<h3 id="tip">Tip</h3>
<h4 id="python中的列表">Python中的列表</h4>
<ol>
<li>列表适合存储相关对象的集合，有大量类似的对象，要将它们作为一个整体，用列表比较合适</li>
<li>python中的列表与其他语言的数组相类似，不过是动态的用起来很easy</li>
<li>在代码中，对象列表用中括号包围，列表对象用逗号分隔</li>
<li>python中的in可以检查成员关系</li>
<li>在运行时扩展列表，append（常用）、extend（用于动态扩展）和insert（插入）</li>
<li>在运行时收缩列表，remove和pop，remove只能remove列表对象，pop根据列表对象所处位置来pop</li>
<li>列表copy时的陷阱，看一下代码吧</li>
<li>其实用列表最舒服的应该是切片，不光在列表中也可以在字符串中</li>
</ol>
<pre><code class="language-python">a = [1,2,3,4]
b = a
print(b)
# [1,2,3,4]
b.append(5)
print(b)
# [1,2,3,4,5]
print(a)
# [1,2,3,4,5]
</code></pre>
<p>我们发现在给b列表增加5时，a也增加了5，这是为什么呢？这是因为a和b都指向了同一个数据，如果修改列表，则另一个也会改变。
如果想要仅仅只是复制，则用copy和deepcopy，区别的话，占个坑，之后再说。
现在举一个切片的栗子，我觉得比较厉害的</p>
<pre><code class="language-python">a = [1,2,3]
print(a[::-1])
# [3,2,1]
</code></pre>
<p>可能也不是很厉害，记住一点就是与其他语言不同的是，python允许从任意两端索引，使用-1会选择列表中的最后一项，-2会选择倒数第2个对象，以此类推。</p>
<h3 id="share">Share</h3>
<p>分享一篇关于如何学习Java并发编程<a href="https://www.infoq.cn/article/1ggzj_oFl8wuJFwVG9et">简明高效的 Java 并发编程学习指南</a></p>
]]></content>
    </entry>
</feed>